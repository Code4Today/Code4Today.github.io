<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[*LeetCode 16. 3Sum Closest (Medium)]]></title>
    <url>%2F2019%2FLeetCode-16-3Sum-Closest-Medium%2F</url>
    <content type="text"><![CDATA[Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 在数组中寻找三个数，使其和最接近目标数，并返回这个和。 这题我的解法是循环第一个数，简化成两数之和的问题，然后通过双指针的方法解决两数之和的问题即可。注意循环第一个数的时候注意跳过重复的数，可以大大加快时间。 1234567891011121314151617181920212223242526272829class Solution(object): def threeSumClosest(self, nums, target): """ :type nums: List[int] :type target: int :rtype: int """ return self.sortedTwoPointer(nums, target) def sortedTwoPointer(self, nums, target): n = len(nums) nums.sort() res = float('inf') for idx1 in xrange(n - 2): if idx1 &gt; 0 and nums[idx1] == nums[idx1 - 1]: continue left, right = idx1 + 1, n - 1 while left != right: tmp = nums[idx1] + nums[left] + nums[right] if abs(tmp - target) &lt; abs(res - target): res = tmp if tmp == target: return target elif tmp &lt; target: left += 1 else: right -= 1 return res]]></content>
  </entry>
  <entry>
    <title><![CDATA[*LeetCode 136. Single Number (Easy)]]></title>
    <url>%2F2018%2FLeetCode-136-Single-Number-Easy%2F</url>
    <content type="text"><![CDATA[Given a non-empty array of integers, every element appears twice except for one. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: Input: [2,2,1] Output: 1 Example 2: Input: [4,1,2,1,2] Output: 4 一个非空数组中其他数字都出现了两次，只有一个只出现过一次的数字。求这个数字。 一种方法是用List/Dict记录出现过的数字。由于Dict可以用哈希表，所以明显要快。这里要注意，如果用的是if x in d.keys()这种写法，会先生成一个d.keys()的list，从而降低速度。应该直接用try .. except的写法。 另一种方法比较巧妙，我们可以发现 a^a = 0，a^0 = a所以如果我们把所有的数字异或一遍，得到的结果就是只出现一次的数字。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution(object): def singleNumber(self, nums): """ :type nums: List[int] :rtype: int """ return self.apXOR(nums) def apList(self, nums): re = [] for num_itr in nums: if num_itr in re: re.remove(num_itr) else: re.append(num_itr) return re[0] def apDict(self, nums): re = &#123;&#125; for num_itr in nums: if num_itr in re.keys(): re.pop(num_itr) else: re[num_itr] = 0 return re.keys()[0] def apDictImp(self, nums): re = &#123;&#125; for num_itr in nums: try: re.pop(num_itr) except: re[num_itr] = 0 return re.keys()[0] def apMath(self, nums): return 2*sum(set(nums))-sum(nums) def apXOR(self, nums): re = 0 for num_itr in nums: re ^= num_itr return re]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[*LeetCode 121. Best Time to Buy and Sell Stock (Easy)]]></title>
    <url>%2F2018%2FLeetCode-121-Best-Time-to-Buy-and-Sell-Stock-Easy%2F</url>
    <content type="text"><![CDATA[Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example 1: Input: [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Not 7-1 = 6, as selling price needs to be larger than buying price. Example 2: Input: [7,6,4,3,1] Output: 0 Explanation: In this case, no transaction is done, i.e. max profit = 0. 有一个股价的数组，只能做一次交易，求最大利润。 一种做法是记下当前为止的最小价格，然后将当前价格减去最小价格，比较交易利润。另一种是转化为最大子数列问题，用Kadane’s Algorithm求解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution(object): def maxProfit(self, prices): """ :type prices: List[int] :rtype: int """ # self.testSet(self.apKadane) return self.apKadane(prices) def apKadane(self, prices): max_ending_here = max_so_far = 0 for itr in range(1, len(prices)): max_ending_here = max(0, max_ending_here + prices[itr] - prices[itr - 1]) max_so_far = max(max_so_far, max_ending_here) return max_so_far def apCompareMin(self, prices): re, min_price = 0, float("inf") for price_itr in prices: min_price = min(min_price, price_itr) re = max(re, price_itr - min_price) return re def apBruteForce(self, prices): re = 0 for start_itr in range(len(prices) - 1): for end_itr in range(start_itr + 1, len(prices)): re = max(prices[end_itr] - prices[start_itr], re) return re def testSet(self, ap): test_data = [ ([], 0), ([3], 0), ([7,1,5,3,6,4], 5), ([7,6,4,3,1], 0), ([1,4,5,3,6,9], 8), ] test_passed = True for test_itr in test_data: if ap(test_itr[0]) != test_itr[1]: test_passed = False print 'In:', test_data[0], 'Out:', ap(test_data[0]), 'Ans:', test_data[1] if test_passed: print 'All test has been passed.']]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 119. Pascal's Triangle II (Easy) RCS]]></title>
    <url>%2F2018%2FLeetCode-119-Pascal-s-Triangle-II-Easy%2F</url>
    <content type="text"><![CDATA[Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal&apos;s triangle. Note that the row index starts from 0. In Pascal&apos;s triangle, each number is the sum of the two numbers directly above it. Example: Input: 3 Output: [1,3,3,1] Follow up: Could you optimize your algorithm to use only O(k) extra space? 这题只要求返回一行的数据。 我测试了三种方法：一种是递归，另一种是列表内循环处理，最后一种是直接带公式。由于公式必须算乘除法，实际上没有递归的加减法快。 1234567891011121314151617181920212223242526272829303132333435from collections import dequeclass Solution(object): def getRow(self, rowIndex): """ :type rowIndex: int :rtype: List[int] """ return self.apSpaceKDeque(rowIndex) def apRecursive(self, rowIndex): if rowIndex == 0: return [1] else: rowBefore = self.apRecursive(rowIndex - 1) return [x + y for x, y in zip([0] + rowBefore, rowBefore + [0]) ] # return map(lambda x, y: x + y, [0] + rowBefore, rowBefore + [0]) def apSpaceK(self, rowIndex): res = [1] for itr in range(rowIndex): for idx in range(len(res) - 1, 0, -1): res[idx] += res[idx - 1] res.append(1) return res def apFormula(self, rowIndex): res = [1] for itr in range(1, rowIndex/2 + 1): res.append(res[-1] * (rowIndex - itr + 1) / itr) if rowIndex % 2 == 1: res += res[::-1] else: res += res[::-1][1:] return res]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>RCS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[*LeetCode 118. Pascal's Triangle (Easy) RCS]]></title>
    <url>%2F2018%2FLeetCode-118-Pascal-s-Triangle-Easy-RCS%2F</url>
    <content type="text"><![CDATA[Given a non-negative integer numRows, generate the first numRows of Pascal&apos;s triangle. In Pascal&apos;s triangle, each number is the sum of the two numbers directly above it. Example: Input: 5 Output: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 生成一个Pascal三角形。 这题用迭代或循环即可。最后提供了一种简洁的用Map函数的解法。 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def generate(self, numRows): """ :type numRows: int :rtype: List[List[int]] """ return self.apMap(numRows) def apIterative(self, numRows): if numRows == 0: return [] else: result = [[1]] for itr in range(1, numRows): result.append([1]) for col in range(len(result[itr - 1]) - 1): result[itr].append(result[itr - 1][col] + result[itr - 1][col + 1]) result[itr].append(1) return result def apRecursive(self, numRows): if numRows == 0: return [] elif numRows == 1: return [[1]] else: result = self.apRecursive(numRows - 1) result.append([1] + [sum(result[-1][i:i+2]) for i in range((len(result[-1]) - 1))] + [1]) return result def apMap(self, numRows): if numRows == 0: return [] else: result = [[1]] for itr in range(1, numRows): result += [map(lambda x, y: x + y, [0] + result[-1], result[-1] + [0])] return result]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>RCS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[**LeetCode 110. Balanced Binary Tree (Easy) RCS Tree]]></title>
    <url>%2F2018%2FLeetCode-110-Balanced-Binary-Tree-Easy%2F</url>
    <content type="text"><![CDATA[Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example 1: Given the following tree [3,9,20,null,null,15,7]: 3 / \ 9 20 / \ 15 7 Return true. Example 2: Given the following tree [1,2,2,3,3,null,null,4,4]: 1 / \ 2 2 / \ 3 3 / \ 4 4 Return false. 判断一棵树是不是平衡二叉树。 平衡二叉树的定义就是每个节点的左右子树高度都相同。需要注意考虑的是 [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] [1,2,2,3,null,null,3,4,null,null,4] 两种情况。 第一种算法是递归每个节点求左右节点的高度，如果高度相差超过1则返回False，然后判断左右节点。由于每个节点都需要求一次高度，其实对于每个节点，都需要遍历一遍子树，所以时间复杂度为O(n^2)。 第二种算法是用高度为-1记录False的情况，这样只需要遍历一次即可完成判断。时间复杂度为O(n)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isBalanced(self, root): """ :type root: TreeNode :rtype: bool """ return self.apRecursiveImproved(root) # Time: O(n^2) def apRecursive(self, root): if root: return -1 &lt;= self.depthOfLeaves(root.left) - self.depthOfLeaves(root.right) &lt;= 1 and self.apRecursive(root.left) and self.apRecursive(root.right) else: return True def depthOfLeaves(self, node): if node: max_left = self.depthOfLeaves(node.left) max_right = self.depthOfLeaves(node.right) return max(max_left, max_right) + 1 else: return 0 # Time: O(n) def apRecursiveImproved(self, root): return self.checkHeight(root) != -1 def checkHeight(self, node): if node: max_left = self.checkHeight(node.left) max_right = self.checkHeight(node.right) if max_left == -1 or max_right == -1 or abs(max_left - max_right) &gt; 1: return -1 return max(max_left, max_right) + 1 else: return 0]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>RCS</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[*LeetCode 258. Add Digits (Easy)]]></title>
    <url>%2F2018%2FLeetCode-258-Add-Digits-Easy%2F</url>
    <content type="text"><![CDATA[Given a non-negative integer num, repeatedly add all its digits until the result has only one digit. Example: Input: 38 Output: 2 Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. Follow up: Could you do it without any loop/recursion in O(1) runtime? 给出一个非负数，重复叠加它的所有数字，直到只剩一位数为止。 一种方法就是重复叠加，直到求出结果。另一种方法就是寻找规律，发现其实是求除9的余数，不过余数是0的时候应该返回9. 12345678910111213141516171819202122232425262728293031323334353637383940class Solution(object): def addDigits(self, num): """ :type num: int :rtype: int """ # self.testSet(self.apFormula2) return self.apFormula2(num) def apFormula2(self, num): if num: return num - (num - 1) / 9 * 9 else: return 0 def apFormula(self, num): if num: return (num - 1) % 9 + 1 else: return 0 def apBruteForce(self, num): while num &gt; 9: num = num / 10 + num % 10 return num def testSet(self, ap): test_data = [ (0, 0), (38, 2), (487, 1), (9876, 3), ] test_valid = True for test_itr in test_data: if ap(test_itr[0]) != test_itr[1]: print 'In:', test_itr[0],'Out:', ap(test_itr[0]), 'Ans:', test_itr[1] test_valid = False if test_valid: print 'All test has been passed.']]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[*LeetCode 108. Convert Sorted Array to Binary Search Tree (Easy) BS]]></title>
    <url>%2F2018%2FLeetCode-108-Convert-Sorted-Array-to-Binary-Search-Tree-Easy-BS%2F</url>
    <content type="text"><![CDATA[Given an array where elements are sorted in ascending order, convert it to a height balanced BST. For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. Example: Given the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 用一个排序好的数组组成一个高度平衡的二叉树。 用二分查找找到中心点，然后左右分别为树的左右分支即可。 123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def sortedArrayToBST(self, nums): """ :type nums: List[int] :rtype: TreeNode """ return self.apRecursive(nums) def apRecursive(self, nums): return self.binarySearch(nums, 0, len(nums)-1) def binarySearch(self, nums, begin, end): if begin &lt;= end: mid = (begin + end)/2 tree = TreeNode(nums[mid]) tree.left = self.binarySearch(nums, begin, mid - 1) tree.right = self.binarySearch(nums, mid + 1, end) else: tree = None return tree]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>BS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[*LeetCode 107. Binary Tree Level Order Traversal II (Easy) BFS DFS]]></title>
    <url>%2F2018%2FLeetCode-107-Binary-Tree-Level-Order-Traversal-II-Easy-BFS-DFS%2F</url>
    <content type="text"><![CDATA[Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root). For example: Given binary tree [3,9,20,null,null,15,7], return its bottom-up level order traversal as:[ [15,7], [9,20], [3]] 给定一颗二叉树，返回一个从底层到顶层的List。 和之前BFS、DFS的问题差不多，注意顺序即可。DFS要注意list先加右边的node，再加左边的node，这样顺序才不会反过来。 123456789101112131415161718192021222324252627282930313233343536373839404142# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def levelOrderBottom(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ return self.apDFS(root) def apDFS(self, root): stack = [(root, 0)] up_bottom_list = [] while stack != []: node, depth = stack.pop() if node: if depth &lt; len(up_bottom_list): up_bottom_list[depth].append(node.val) else: up_bottom_list.append([node.val]) stack.append((node.right, depth + 1)) stack.append((node.left, depth + 1)) return up_bottom_list[::-1] def apBFS(self, root): stack = [(root, 0)] up_bottom_list = [] while stack != []: node, depth = stack.pop(0) if node: if depth &lt; len(up_bottom_list): up_bottom_list[depth].append(node.val) else: up_bottom_list.append([node.val]) stack.append((node.left, depth + 1)) stack.append((node.right, depth + 1)) return up_bottom_list[::-1]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 104. Maximum Depth of Binary Tree (Easy) BFS DFS]]></title>
    <url>%2F2018%2FLeetCode-104-Maximum-Depth-of-Binary-Tree-Easy-BFS-DFS%2F</url>
    <content type="text"><![CDATA[Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Note: A leaf is a node with no children. Example: Given binary tree [3,9,20,null,null,15,7], return its depth = 3. 给定一颗二叉树，求其最大深度。 这题其实和100题，101题很像，也是递归、DFS、BFS三种解法，不再详述。 1234567891011121314151617181920212223242526272829303132333435363738394041424344# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def maxDepth(self, root): """ :type root: TreeNode :rtype: int """ return self.apBFS(root) def apRecursive(self, root): return self.depthOfNode(root, 1) def depthOfNode(self, node, depth_of_node): if node: return max(self.depthOfNode(node.left, depth_of_node + 1), self.depthOfNode(node.right, depth_of_node + 1)) return depth_of_node - 1 def apDFS(self, root): stack = [(root, 1)] max_depth = 0 while stack: node, depth = stack.pop() if node: max_depth = max(depth, max_depth) stack.append((node.left, depth + 1)) stack.append((node.right, depth + 1)) return max_depth def apBFS(self, root): stack = [(root, 1)] max_depth = 0 while stack: node, depth = stack.pop(0) if node: max_depth = max(depth, max_depth) stack.append((node.left, depth + 1)) stack.append((node.right, depth + 1)) return max_depth]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[**LeetCode 53. Maximum Subarray (Easy) DP BS]]></title>
    <url>%2F2018%2FLeetCode-53-Maximum-Subarray-Easy%2F</url>
    <content type="text"><![CDATA[Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. 求数组nums的和最大的子数组，返回这个最大的和。 这题如果用暴力迭代的话，需要时间复杂度O(n^2)。所以这里有一种很巧妙的办法，动态规划。首先考虑只有一个数字的数组，那么就是他本身，如果有两个数字，包含第一个数字的最大子数组就考虑新加入的数字是否大于0，而包含第二个数字的最大子数组就考虑原先的数字是否大于0。如此迭代，我们可以得到一个到此数字为止包含此数字的最大子数组和的数组。最后，找出这个数组的最大值即可。时间复杂度为O(n)。 题目还要求用二分法的方法做。将数组分为左右两个子数组。这时有三种情况： 最大的子数组在左边 最大的子数组在右边 最大的子数组横跨左右 前两种都好解决，直接继续迭代即可。最后一种情况需要我们分别计算出左边数组的包含右边界的子数组的最大值和右边数组的包含左边界的子数组最大值，然后将二者相加。比较出三种情况的最大值即为所需结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class Solution(object): def maxSubArray(self, nums): """ :type nums: List[int] :rtype: int """ # self.testSet(self.apDivideAndConquer) return self.apDivideAndConquer(nums) def apDivideAndConquer(self, nums): if nums == None or len(nums) == 0: return 0 else: return self.subArrayMax(nums, 0, len(nums) - 1) def subArrayMax(self, nums, begin, end): if begin == end: return nums[begin] else: mid = (begin + end) / 2 left_max = self.subArrayMax(nums, begin, mid) right_max = self.subArrayMax(nums, mid + 1, end) left_right_sum_max = left_right_sum = nums[mid] for i_itr in range(mid - 1, begin - 1, -1): left_right_sum += nums[i_itr] left_right_sum_max = max(left_right_sum_max, left_right_sum) right_left_sum_max = right_left_sum = nums[mid+1] for i_itr in range(mid + 2, end + 1, 1): right_left_sum += nums[i_itr] right_left_sum_max = max(right_left_sum_max, right_left_sum) return max(left_max, right_max, left_right_sum_max + right_left_sum_max) def apMaxForEachElementImproved(self, nums): if nums == None or len(nums) == 0: return 0 elif len(nums) == 1: return nums[0] else: for i_itr in range(1, len(nums)): if nums[i_itr - 1] &gt; 0: nums[i_itr] += nums[i_itr - 1] return max(nums) def apMaxForEachElement(self, nums): if nums == None or len(nums) == 0: return 0 elif len(nums) == 1: return nums[0] else: max_list = [nums[0]] for i_itr in range(1, len(nums)): if max_list[i_itr - 1] &gt; 0: max_list.append(max_list[i_itr - 1] + nums[i_itr]) else: max_list.append(nums[i_itr]) return max(max_list) def apBruteForce(self, nums): if nums == None or len(nums) == 0: return 0 elif len(nums) == 1: return nums[0] else: sum_max = -float('inf') for list_begin in range(len(nums)): for list_end in range(list_begin+1, len(nums)+1): sum_temp = sum(nums[list_begin:list_end]) sum_max = max(sum_temp, sum_max) return sum_max def testSet(self, ap): test_data = [ ([-2, 1, -3, 4, -1, 2, 1, -5, 4], 6), ([6, 3, -1, -1, -1, 7], 13), ([], 0), ([-2], -2), ([6, -2], 6), ([9, -10, 4, 5, 6, -1], 15), ([-1, 4, 5, -1, 6, 2], 16), ] test_passed = True for test_itr in test_data: if ap(test_itr[0]) != test_itr[1]: test_passed = False print 'In:', test_itr[0], 'Out:', ap(test_itr[0]), 'Answer:', test_itr[1] if test_passed: print 'All test has been passed.']]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DP</tag>
        <tag>BS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 58. Length of Last Word (Easy)]]></title>
    <url>%2F2018%2FLeetCode-58-Length-of-Last-Word-Easy%2F</url>
    <content type="text"><![CDATA[Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string. If the last word does not exist, return 0. Note: A word is defined as a character sequence consists of non-space characters only. Example: Input: “Hello World” Output: 5 求字符串中的最后一个单词的长度。 这题主要是要注意特殊情况，比如没有最后一个单词的情况，以及最后是空格的情况。从这题开始，尽量都先写测试集。 123456789101112131415161718192021222324252627282930313233343536class Solution(object): def lengthOfLastWord(self, s): """ :type s: str :rtype: int """ # self.testSet(self.apSplit) return self.apSplit(s) def apSplit(self, s): if s == None or len(s) == 0: return 0 else: l = s.split(' ') for word_itr in l[::-1]: if word_itr != '': return len(word_itr) return 0 def testSet(self, ap): test_data = [ ('a', 1), ('hello world', 5), ('', 0), ('a ', 1), ('a ', 1), (' ', 0) ] test_passed = True for test_itr in test_data: if ap(test_itr[0]) != test_itr[1]: test_passed = False print 'In:', test_itr[0], 'Out:', ap(test_itr[0]), 'Ans:', test_itr[1] if test_passed: print 'All test has been passed.']]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 101. Symmetric Tree (Easy) BFS DFS]]></title>
    <url>%2F2018%2FLeetCode-101-Symmetric-Tree-Easy%2F</url>
    <content type="text"><![CDATA[Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: But the following [1,2,2,null,3,null,3] is not: Note: Bonus points if you could solve it both recursively and iteratively. 求一颗二叉树是否完全对称。 解法和100题差不多，就不再说了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isSymmetric(self, root): """ :type root: TreeNode :rtype: bool """ return self.apDFS(root) def apRecursive(self, root): if root: return self.recurseTwoTrees(root.left, root.right) return True def recurseTwoTrees(self, node_left, node_right): if node_left and node_right: return node_left.val == node_right.val and self.recurseTwoTrees(node_left.left, node_right.right) and self.recurseTwoTrees(node_left.right, node_right.left) else: return node_left == node_right def apBFS(self, root): if root: node_stack = [(root.left, root.right)] while node_stack: node1, node2 = node_stack.pop(0) if node1 and node2: if node1.val == node2.val: node_stack.append((node1.left, node2.right)) node_stack.append((node1.right, node2.left)) else: return False else: if node1 != node2: return False return True def apDFS(self, root): if root: node_stack = [(root.left, root.right)] while node_stack: node1, node2 = node_stack.pop() if node1 and node2: if node1.val == node2.val: node_stack.append((node1.left, node2.right)) node_stack.append((node1.right, node2.left)) else: return False else: if node1 != node2: return False return True]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[*LeetCode 100. Same Tree (Easy) BFS DFS]]></title>
    <url>%2F2018%2FLeetCode-100-Same-Tree%2F</url>
    <content type="text"><![CDATA[Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input: [1,2,3], [1,2,3] Output: true Example 2: Input: [1,2], [1,null,2] Output: false Example 3: Input: [1,2,1], [1,1,2] Output: false 有两个二叉树，确定这两个二叉树是否完全相同。 第一种解法是递归解法，判断val相同后递归查找左右子树是否相同。 第二种解法是BFS/DFS解法，核心是用一个list记录下中心点，比较完val后将左右子树分别加入list，循环直到list为空为止。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isSameTree(self, p, q): """ :type p: TreeNode :type q: TreeNode :rtype: bool """ return self.apBFSStack(p, q) def apRecursive(self, p, q): if p and q: return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) else: return p == q def apDFSStack(self, p, q): stack = [(p, q)] while stack: n1, n2 = stack.pop() if n1 and n2: if n1.val != n2.val: return False else: stack.append((n1.left, n2.left)) stack.append((n1.right, n2.right)) else: if n1 != n2: return False return True def apBFSStack(self, p, q): stack = [(p, q)] while stack: n1, n2 = stack.pop(0) if n1 and n2: if n1.val != n2.val: return False else: stack.append((n1.left, n2.left)) stack.append((n1.right, n2.right)) else: if n1 != n2: return False return True]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[***LeetCode 70. Climbing Stairs (Easy) DP]]></title>
    <url>%2F2018%2FLeetCode-70-Climbing-Stairs%2F</url>
    <content type="text"><![CDATA[You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1: Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1 step + 1 step 2 steps Example 2: Input: 3 Output: 3 Explanation: There are three ways to climb to the top. 1 step + 1 step + 1 step 1 step + 2 steps 2 steps + 1 step 一共n层阶梯，一次可以上一层或两层阶梯，问上到阶梯顶部的方法有多少种？ 这是一个非常经典的递归问题了。 第一反应自然是用递归做，递归的时候记得存储每次的结果，不然递归会很慢。递归解法时间复杂度O(n)（不存储结果的话为O(2^n)），空间复杂度O(n) 第二种解法是，其实这个问题的本质是斐波那契数列，所以直接计算该数列，记住最后两个结果即可，不用记住前面的结果，所以时间复杂度O(n)，空间复杂度O(1) 第三种解法很有趣，我们可以发现矩阵关系[[Fn+1, Fn], [Fn, Fn-1]] = ([[1, 1], [1, 0]])^(n+1)，所以我们只需要对该矩阵求n次幂，左上角的结果即为Fn。而对矩阵求n次幂可以二分为求n/2次幂的平方，如此迭代后时间复杂度为O(log(n))，空间复杂度为O(1) 第四种解法就是直接带斐波那契数列的公式，由于存在幂次，所以时间复杂度为O(log(n))，空间复杂度为O(1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from math import sqrtimport copyclass Solution(object): climb_list = [0, 1, 2] + [0] * 65535 def climbStairs(self, n): """ :type n: int :rtype: int """ # self.testSet(self.apFormula) return self.apFormula(n) def apFormula(self, n): return int(1/sqrt(5)*(((1 + sqrt(5))/2)**(n+1) - ((1 - sqrt(5))/2)**(n+1))) def apMatrix(self, n): q = [[1, 1], [1, 0]] return self.matrixPower(q, n)[0][0] def matrixPower(self, q, n): ret = [[1, 0], [0, 1]] while n &gt; 0: if n &amp; 1 == 1: ret = self.matrixMul(ret, q) n &gt;&gt;= 1 q = self.matrixMul(q, q) return ret def matrixMul(self, m1, m2): r = [] for row in range(2): r.append([]) for col in range(2): r[row].append(m1[row][0] * m2[0][col] + m1[row][1] * m2[1][col]) return r def apDynamicProgram(self, n): if n == 1: return 1 elif n == 2: return 2 else: prev = 1 now = 2 while n &gt; 2: prev, now = now, prev + now n -= 1 return now def apRecursion(self, n): if self.climb_list[n] == 0: self.climb_list[n] = self.apRecursion(n - 1) + self.apRecursion(n - 2) return self.climb_list[n] def testSet(self, ap): test_data = [ (1, 1), (2, 2), (3, 3), (8, 34), (7, 21), ] test_pass = True for test_itr in test_data: if ap(test_itr[0]) != test_itr[1]: test_pass = False print 'In:', test_itr[0], "Out:", ap(test_itr[0]), 'Ans:', test_itr[1] if test_pass: print 'All test has been passed.']]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[*LeetCode 69. Sqrt(x) (Easy) BS]]></title>
    <url>%2F2018%2FLeetCode-69-Sqrt-x-Easy%2F</url>
    <content type="text"><![CDATA[Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4 Output: 2 Example 2: Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842…, and since the decimal part is truncated, 2 is returned. 给出一个数x，求x的平方根取整后的结果。 这题有两种解法，一种是从x开始二分查找，最终确定x，另一种是按位确定x的范围，其实也是一种二分查找，不过代码比较简洁。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution(object): def mySqrt(self, x): """ :type x: int :rtype: int """ # self.testSet(self.apBitSearch) return self.apBitSearch(x) def apBitSearch(self, x): ans = 0 bit = 1l &lt;&lt; 16 while bit &gt; 0: ans |= bit if ans * ans &gt; x: ans ^= bit bit &gt;&gt;= 1 return ans def apBinarySearch(self, x): low, high = 1, x while high &gt; low: mid = (low + high) / 2 if mid ** 2 &gt; x: high = mid - 1 elif mid ** 2 &lt;= x: low = mid + 1 if low ** 2 &gt; x: return low - 1 else: return low def testSet(self, ap): test_data = [ (1, 1), (2, 1), (3, 1), (4, 2), (8, 2), (17, 4), (404, 20), (900, 30), ] test_pass = True for test_itr in test_data: if ap(test_itr[0]) != test_itr[1]: test_pass = False print 'In:', test_itr[0], 'Out:', ap(test_itr[0]), 'Ans:', test_itr[1] if test_pass: print 'All test has been passed.']]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 67. Add Binary (Easy)]]></title>
    <url>%2F2018%2FLeetCode-67-Add-Binary-Easy%2F</url>
    <content type="text"><![CDATA[Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0. Example 1: Input: a = “11”, b = “1” Output: “100” Example 2: Input: a = “1010”, b = “1011” Output: “10101” 给定a,b两个字符串，分别代表两个数的二进制值，计算他们和的二进制值。 这里就是简单的相加，自己写函数的话就是单位相加进位，没太大可写之处，所以直接用了bin函数。 12345678class Solution(object): def addBinary(self, a, b): """ :type a: str :type b: str :rtype: str """ return bin(int(a, 2) + int(b, 2))[2:]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 83. Remove Duplicates from Sorted List (Easy)]]></title>
    <url>%2F2018%2FLeetCode-83-Remove-Duplicates-from-Sorted-List%2F</url>
    <content type="text"><![CDATA[Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1-&gt;1-&gt;2 Output: 1-&gt;2 Example 2: Input: 1-&gt;1-&gt;2-&gt;3-&gt;3 Output: 1-&gt;2-&gt;3 这题就是将链表中的重复数据删除掉，遍历一遍链表，查看该节点的值是否与下一个节点相同，相同的话替换掉下一个节点，循环到最后即可。注意空链表的情况。 如果需要考虑链表有环的情况的话，就先用一快一慢两个指针先遍历一遍链表，一个每次移动一节，一个每次移动两节，看两个指针最终是重合还是有一个到达了终点。这里代码里没有写这种情况，有兴趣的可以自己写一下。 1234567891011121314151617181920# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ if head: itr = head while itr and itr.next: if itr.val == itr.next.val: itr.next = itr.next.next else: itr = itr.next return head]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 88. Merge Sorted Array (Easy)]]></title>
    <url>%2F2018%2FLeetCode-88-Merge-Sorted-Array-Easy%2F</url>
    <content type="text"><![CDATA[Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively.You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.Example: Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] 这题的意思很简单，就是有nums1, nums2两个排好序的数组，假设nums1具有足够的空间，将nums1改成两个数组合并后的排序数组。注意要在nums1上直接改动而不是新建一个数组。 由于nums1后面都是闲置的0，从后面倒过来排序即可。代码： 1234567891011121314151617181920212223class Solution(object): def merge(self, nums1, m, nums2, n): """ :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. """ return self.sortFromMax(nums1, m, nums2, n) def sortFromMax(self, nums1, m, nums2, n): idx_itr = m + n while m &gt; 0 and n &gt; 0: if nums1[m - 1] &gt; nums2[n - 1]: nums1[idx_itr - 1] = nums1[m - 1] m, idx_itr = m - 1, idx_itr - 1 else: nums1[idx_itr - 1] = nums2[n - 1] n, idx_itr = n - 1, idx_itr - 1 while n &gt; 0: nums1[idx_itr - 1] = nums2[n - 1] n, idx_itr = n - 1, idx_itr - 1]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 66. Plus One (Easy)]]></title>
    <url>%2F2018%2FLeetCode-66-Plus-One%2F</url>
    <content type="text"><![CDATA[Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: Input: [1,2,3]Output: [1,2,4]Explanation: The array represents the integer 123.Example 2: Input: [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321. 这题其实很简单，意思就是，输入的list代表了一个非负整数，为这个数加上1，还用这种list表示。我的解法是简单的从最后一位开始+1，有进位进位即可。 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ # self.testSet(self.apAddFromLast) return self.apAddFromLast(digits) # Time: O(n) Space: O(n) def apAddFromLast(self, digits): i = len(digits) - 1 while i &gt;= 0: if digits[i] &lt; 9: digits[i] += 1 return digits else: digits[i] = 0 i -= 1 digits.insert(0, 1) return digits def testSet(self, ap): test_data = [ ([1, 2, 3], [1, 2, 4]), ([4, 3, 2, 1], [4, 3, 2, 2]), ([9], [1, 0]), ([9, 9, 9, 9], [1, 0, 0, 0, 0]), ([0], [1]), ([], [1]), ] test_pass = True for test_itr in test_data: if ap(test_itr[0]) != test_itr[1]: test_pass = False print 'In:', test_itr[0], 'Out:', ap(test_itr[0]), 'Ans:', test_itr[1] if test_pass: print 'All test has been passed.']]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建（三）其他优化]]></title>
    <url>%2F2018%2Fblog3%2F</url>
    <content type="text"><![CDATA[经过了前两个步骤，其实我们已经拥有了自己的博客，用Markdown就可以开始编写自己的博文了。下面是尝试的一些其他优化，由于内容较多，不再一一叙述，大家可以通过链接自行尝试~ 首先我们再次回顾之前讲的搭建博客的步骤： 在本地创建好博客文件并上传到github上，这样就可以在github上浏览自己的博客啦，详见这里 包括安装Node.js, git，hexo，注册github帐号等 为自己的博客设置一个域名，这样就可以从个性化的域名里直接访问博客，详见这里 包括域名购买，dns设置，pages设置等 其他优化，详见这里 本篇为第三部分，优化的几个方面主要为： 主题 是否觉得博客页面不好看，想要换一个别人设计好的主题？试试Next主题 Hexo的Next主题配置 评论 觉得只有自己的博文太单调，别人无法评论？综合了多个评论系统，最后我选择了valine 为你的Hexo加上评论系统-Valine 双托管 自己的博客的访问速度太慢了？这主要是由于Github在国内的访问速度不稳定，试试Coding+Github双托管吧！ Coding+Github双服务器托管个人博客 编写博客 感觉没有一个称手的Markdown编辑器，每次编写完还要手动提交，好麻烦？试试Hexo admin吧，可视化界面，一键发布博客！ Hexo Admin Plugin 其他的一些功能就要靠大家自己慢慢去发掘了，希望每个人都可以拥有自己的一片天地~]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建（二）NameSilo+dnspod建立自己的域名]]></title>
    <url>%2F2018%2Fblog2%2F</url>
    <content type="text"><![CDATA[上一篇我们讲到了我们在Github上建立好了自己的个人博客，但是由于博客是部署在Github上的，访问的时候必须输入username.github.io，这样作为个人博客是不是有点别扭呢？为了能有一个个性化的域名，就需要进行本篇的操作啦。 首先来回顾一下上次我们讲的搭建博客的步骤： 在本地创建好博客文件并上传到github上，这样就可以在github上浏览自己的博客啦，详见这里 包括安装Node.js, git，hexo，注册github帐号等 为自己的博客设置一个域名，这样就可以从个性化的域名里直接访问博客，详见这里 包括域名购买，dns设置，pages设置等 其他优化，详见这里 域名购买目前其实有很多的网站可供选择，比如国内的阿里云，国外的GoDaddy, NameCheap，NameSilo等等。综合考虑了各方因素，最后我是在NameSilo上买的，还支持支付宝付款，非常方便。 域名购买之后，要让别人能够成功访问到这个域名，就需要设置DNS，这里用的是DNSPod的服务，添加域名后选择记录类型为CNAME，记录值为code4today.github.io.主机类型为@/www分别设置一条。这里以本域名为例解释下，主机类型为@指的是访问的是code4today.xyz，主机类型为www指的是访问的是www.code4today.xyz，为了让两个网址都能被访问，需要把两个类型都添加一次。细心的朋友会发现上面的记录值的最后会有一个小点点，即使你没打他也会自动添加上去，如果不加这个小点报错了的话就要手动加上去。添加后，不要着急，一般过个一两天，DNS才能刷新成功。 这里吐槽一下，我也用过阿里云的DNS访问，不过不知道是为什么设置了一直都不成功= = 最后，我们记得在github的pages设置里设置一下自己的域名，才能成功从自己的域名跳转过去。点开自己的Github pages仓库，选择”Settings”，然后找到”Custom domain”，在里面输入自己的域名，保存后就可以啦~ 静待1~3天后，在浏览器里输入自己的域名，就可以访问自己的博客了！]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建（一）hexo + github 创建博客]]></title>
    <url>%2F2018%2Fblog1%2F</url>
    <content type="text"><![CDATA[一直想自己搭建一个博客，最近在空闲的时候陆陆续续搞了几天终于基本成功了，操作系统为Windows 7 64位。由于安装的时候没有截图，所以安装过程主要是文字，图片可以在最后的参考链接中看到一部分，希望可以给大家一些帮助。 我的搭建流程主要分以下几步： 在本地创建好博客文件并上传到github上，这样就可以在github上浏览自己的博客啦，详见这里 包括安装Node.js, git，hexo，注册github帐号等 为自己的博客设置一个域名，这样就可以从个性化的域名里直接访问博客，详见这里 包括域名购买，dns设置，pages设置等 其他优化，详见这里 本篇主要讲第一部分。 创建本地博客安装Node.js在这里下载Node，然后直接按提示安装即可。 安装git建议直接安装Github Desktop，这样可以直接用图形界面，方便今后往github上传代码。安装的时候会自动安装好git 安装hexo首先在本地创建一个存放博客文件的地方，比如我是放在了D:\blog下面。然后进入文件夹，在空白处按住shift加鼠标右键，选择“在此处打开命令窗口” 进入文件夹，在空白处按住shift加鼠标右键，选择“在此处打开命令窗口”。这里也可以在开始菜单搜索cmd然后一步步cd到文件夹里。 在命令行窗口中输入 sudo npm install -g hexo 安装好hexo后，执行init命令初始化hexo，在命令行窗口中输入 hexo init 然后安装所需要的组件,输入 npm install 至此，全部安装工作已经完成。blog就是你的博客根目录，所有的操作都在里面进行。 生成静态页面 hexo generate（hexo g也可以） 至此，本地博客已经创建完成。 创建github页面建立Github项目在Github上申请一个帐号，然后新建一个项目（repository），项目名为申请的账户名.github.io。 配置SSH配置SSH key，这样以后本地写好博客上传的时候就不需要帐号密码了。 在自己的用户目录下（一般为C:\Users\你的用户名）打开命令窗口，保证当前路径在用户目录下。在命令窗口中输入 ssh-keygen -t rsa -C &quot;xxxxxx@yy.com&quot; 邮箱名替换为自己的邮箱 然后用户目录下就会出现.ssh文件夹，进入文件夹中，打开id_rsa.pub文件（我是用Notepad++打开的），全选复制公钥内容。 登录GitHub，点击右上角账号头像的“▼” -&gt; Settings -&gt; SSH kyes -&gt; Add SSH key Titles随便取，将刚才复制的公钥粘贴到GitHub中Add an SSH key的key输入框，最后“Add Key”。 然后配置账户，分别在命令行窗口中输入 git config --global user.name “your_username” 替换成自己的用户名 git config --global user.email “your_registered_github_Email” 替换成自己的邮箱地址(建议用注册giuhub的邮箱) 配置后，在命令行窗口中输入 ssh -T git@github.com 跳出 Are you sure you want to continue connecting (yes/no)? 的时候，输入yes，出现 Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 后，说明设置成功。 本地配置在自己创建的文件夹中，找到_config.yml文件，修改最后的deploy部分为1234deploy: type: git repository: git@github.com:你的用户名/你的用户名.github.io.git branch: master 然后安装一个扩展，在命令行窗口中输入 npm install hexo-deployer-git --save 安装完成后，使用命令 hexo d -g 即可完成博客的生成与部署了 打开你的用户名.github.io.git，就可以看到自己创建的博客啦 参考网页 https://www.jianshu.com/p/465830080ea9https://www.cnblogs.com/fengxiongZz/p/7707219.htmlhttps://www.cnblogs.com/fengxiongZz/p/7707568.htmlhttps://jingyan.baidu.com/article/a65957f4e91ccf24e77f9b11.html]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[***LeetCode 70. Climbing Stairs]]></title>
    <url>%2F2018%2FLeetCode-70-Climbing-Stairs%2F</url>
    <content type="text"><![CDATA[You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Note: Given n will be a positive integer. Example 1: Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1 step + 1 step 2 steps Example 2: Input: 3 Output: 3 Explanation: There are three ways to climb to the top. 1 step + 1 step + 1 step 1 step + 2 steps 2 steps + 1 step 一共n层阶梯，一次可以上一层或两层阶梯，问上到阶梯顶部的方法有多少种？ 这是一个非常经典的递归问题了。 第一反应自然是用递归做，递归的时候记得存储每次的结果，不然递归会很慢。递归解法时间复杂度O(n)（不存储结果的话为O(2^n)），空间复杂度O(n) 第二种解法是，其实这个问题的本质是斐波那契数列，所以直接计算该数列，记住最后两个结果即可，不用记住前面的结果，所以时间复杂度O(n)，空间复杂度O(1) 第三种解法很有趣，$$x_1$$]]></content>
  </entry>
  <entry>
    <title><![CDATA[*LeetCode 69. Sqrt(x) (Easy)]]></title>
    <url>%2F2018%2FLeetCode-69-Sqrt-x-Easy%2F</url>
    <content type="text"><![CDATA[Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4 Output: 2 Example 2: Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842…, and since the decimal part is truncated, 2 is returned. 给出一个数x，求x的平方根取整后的结果。 这题有两种解法，一种是从x开始二分查找，最终确定x，另一种是按位确定x的范围，其实也是一种二分查找，不过代码比较简洁。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution(object): def mySqrt(self, x): """ :type x: int :rtype: int """ # self.testSet(self.apBitSearch) return self.apBitSearch(x) def apBitSearch(self, x): ans = 0 bit = 1l &lt;&lt; 16 while bit &gt; 0: ans |= bit if ans * ans &gt; x: ans ^= bit bit &gt;&gt;= 1 return ans def apBinarySearch(self, x): low, high = 1, x while high &gt; low: mid = (low + high) / 2 if mid ** 2 &gt; x: high = mid - 1 elif mid ** 2 &lt;= x: low = mid + 1 if low ** 2 &gt; x: return low - 1 else: return low def testSet(self, ap): test_data = [ (1, 1), (2, 1), (3, 1), (4, 2), (8, 2), (17, 4), (404, 20), (900, 30), ] test_pass = True for test_itr in test_data: if ap(test_itr[0]) != test_itr[1]: test_pass = False print 'In:', test_itr[0], 'Out:', ap(test_itr[0]), 'Ans:', test_itr[1] if test_pass: print 'All test has been passed.']]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 67. Add Binary (Easy)]]></title>
    <url>%2F2018%2FLeetCode-67-Add-Binary-Easy%2F</url>
    <content type="text"><![CDATA[Given two binary strings, return their sum (also a binary string). The input strings are both non-empty and contains only characters 1 or 0. Example 1: Input: a = “11”, b = “1” Output: “100” Example 2: Input: a = “1010”, b = “1011” Output: “10101” 给定a,b两个字符串，分别代表两个数的二进制值，计算他们和的二进制值。 这里就是简单的相加，自己写函数的话就是单位相加进位，没太大可写之处，所以直接用了bin函数。 12345678class Solution(object): def addBinary(self, a, b): """ :type a: str :type b: str :rtype: str """ return bin(int(a, 2) + int(b, 2))[2:]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 83. Remove Duplicates from Sorted List (Easy)]]></title>
    <url>%2F2018%2FLeetCode-83-Remove-Duplicates-from-Sorted-List%2F</url>
    <content type="text"><![CDATA[Given a sorted linked list, delete all duplicates such that each element appear only once. Example 1: Input: 1-&gt;1-&gt;2 Output: 1-&gt;2 Example 2: Input: 1-&gt;1-&gt;2-&gt;3-&gt;3 Output: 1-&gt;2-&gt;3 这题就是将链表中的重复数据删除掉，遍历一遍链表，查看该节点的值是否与下一个节点相同，相同的话替换掉下一个节点，循环到最后即可。注意空链表的情况。 如果需要考虑链表有环的情况的话，就先用一快一慢两个指针先遍历一遍链表，一个每次移动一节，一个每次移动两节，看两个指针最终是重合还是有一个到达了终点。这里代码里没有写这种情况，有兴趣的可以自己写一下。 1234567891011121314151617181920# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def deleteDuplicates(self, head): """ :type head: ListNode :rtype: ListNode """ if head: itr = head while itr and itr.next: if itr.val == itr.next.val: itr.next = itr.next.next else: itr = itr.next return head]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 88. Merge Sorted Array (Easy)]]></title>
    <url>%2F2018%2FLeetCode-88-Merge-Sorted-Array-Easy%2F</url>
    <content type="text"><![CDATA[Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: The number of elements initialized in nums1 and nums2 are m and n respectively.You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.Example: Input:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] 这题的意思很简单，就是有nums1, nums2两个排好序的数组，假设nums1具有足够的空间，将nums1改成两个数组合并后的排序数组。注意要在nums1上直接改动而不是新建一个数组。 由于nums1后面都是闲置的0，从后面倒过来排序即可。代码： 1234567891011121314151617181920212223class Solution(object): def merge(self, nums1, m, nums2, n): """ :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. """ return self.sortFromMax(nums1, m, nums2, n) def sortFromMax(self, nums1, m, nums2, n): idx_itr = m + n while m &gt; 0 and n &gt; 0: if nums1[m - 1] &gt; nums2[n - 1]: nums1[idx_itr - 1] = nums1[m - 1] m, idx_itr = m - 1, idx_itr - 1 else: nums1[idx_itr - 1] = nums2[n - 1] n, idx_itr = n - 1, idx_itr - 1 while n &gt; 0: nums1[idx_itr - 1] = nums2[n - 1] n, idx_itr = n - 1, idx_itr - 1]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 66. Plus One (Easy)]]></title>
    <url>%2F2018%2FLeetCode-66-Plus-One%2F</url>
    <content type="text"><![CDATA[Given a non-empty array of digits representing a non-negative integer, plus one to the integer. The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit. You may assume the integer does not contain any leading zero, except the number 0 itself. Example 1: Input: [1,2,3]Output: [1,2,4]Explanation: The array represents the integer 123.Example 2: Input: [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321. 难度：1 有趣度：1 这题其实很简单，意思就是，输入的list代表了一个非负整数，为这个数加上1，还用这种list表示。我的解法是简单的从最后一位开始+1，有进位进位即可。 1234567891011121314151617181920212223242526272829303132333435363738class Solution(object): def plusOne(self, digits): """ :type digits: List[int] :rtype: List[int] """ # self.testSet(self.apAddFromLast) return self.apAddFromLast(digits) # Time: O(n) Space: O(n) def apAddFromLast(self, digits): i = len(digits) - 1 while i &gt;= 0: if digits[i] &lt; 9: digits[i] += 1 return digits else: digits[i] = 0 i -= 1 digits.insert(0, 1) return digits def testSet(self, ap): test_data = [ ([1, 2, 3], [1, 2, 4]), ([4, 3, 2, 1], [4, 3, 2, 2]), ([9], [1, 0]), ([9, 9, 9, 9], [1, 0, 0, 0, 0]), ([0], [1]), ([], [1]), ] test_pass = True for test_itr in test_data: if ap(test_itr[0]) != test_itr[1]: test_pass = False print 'In:', test_itr[0], 'Out:', ap(test_itr[0]), 'Ans:', test_itr[1] if test_pass: print 'All test has been passed.']]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建（三）其他优化]]></title>
    <url>%2F2018%2Fblog3%2F</url>
    <content type="text"><![CDATA[经过了前两个步骤，其实我们已经拥有了自己的博客，用Markdown就可以开始编写自己的博文了。下面是尝试的一些其他优化，由于内容较多，不再一一叙述，大家可以通过链接自行尝试~ 首先我们再次回顾之前讲的搭建博客的步骤： 在本地创建好博客文件并上传到github上，这样就可以在github上浏览自己的博客啦，详见这里 包括安装Node.js, git，hexo，注册github帐号等 为自己的博客设置一个域名，这样就可以从个性化的域名里直接访问博客，详见这里 包括域名购买，dns设置，pages设置等 其他优化，详见这里 本篇为第三部分，优化的几个方面主要为： 主题 是否觉得博客页面不好看，想要换一个别人设计好的主题？试试Next主题 Hexo的Next主题配置 评论 觉得只有自己的博文太单调，别人无法评论？综合了多个评论系统，最后我选择了valine 为你的Hexo加上评论系统-Valine 双托管 自己的博客的访问速度太慢了？这主要是由于Github在国内的访问速度不稳定，试试Coding+Github双托管吧！ Coding+Github双服务器托管个人博客 编写博客 感觉没有一个称手的Markdown编辑器，每次编写完还要手动提交，好麻烦？试试Hexo admin吧，可视化界面，一键发布博客！ Hexo Admin Plugin 其他的一些功能就要靠大家自己慢慢去发掘了，希望每个人都可以拥有自己的一片天地~]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建（二）NameSilo+dnspod建立自己的域名]]></title>
    <url>%2F2018%2Fblog2%2F</url>
    <content type="text"><![CDATA[上一篇我们讲到了我们在Github上建立好了自己的个人博客，但是由于博客是部署在Github上的，访问的时候必须输入username.github.io，这样作为个人博客是不是有点别扭呢？为了能有一个个性化的域名，就需要进行本篇的操作啦。 首先来回顾一下上次我们讲的搭建博客的步骤： 在本地创建好博客文件并上传到github上，这样就可以在github上浏览自己的博客啦，详见这里 包括安装Node.js, git，hexo，注册github帐号等 为自己的博客设置一个域名，这样就可以从个性化的域名里直接访问博客，详见这里 包括域名购买，dns设置，pages设置等 其他优化，详见这里 域名购买目前其实有很多的网站可供选择，比如国内的阿里云，国外的GoDaddy, NameCheap，NameSilo等等。综合考虑了各方因素，最后我是在NameSilo上买的，还支持支付宝付款，非常方便。 域名购买之后，要让别人能够成功访问到这个域名，就需要设置DNS，这里用的是DNSPod的服务，添加域名后选择记录类型为CNAME，记录值为code4today.github.io.主机类型为@/www分别设置一条。这里以本域名为例解释下，主机类型为@指的是访问的是code4today.xyz，主机类型为www指的是访问的是www.code4today.xyz，为了让两个网址都能被访问，需要把两个类型都添加一次。细心的朋友会发现上面的记录值的最后会有一个小点点，即使你没打他也会自动添加上去，如果不加这个小点报错了的话就要手动加上去。添加后，不要着急，一般过个一两天，DNS才能刷新成功。 这里吐槽一下，我也用过阿里云的DNS访问，不过不知道是为什么设置了一直都不成功= = 最后，我们记得在github的pages设置里设置一下自己的域名，才能成功从自己的域名跳转过去。点开自己的Github pages仓库，选择”Settings”，然后找到”Custom domain”，在里面输入自己的域名，保存后就可以啦~ 静待1~3天后，在浏览器里输入自己的域名，就可以访问自己的博客了！]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客搭建（一）hexo + github 创建博客]]></title>
    <url>%2F2018%2Fblog1%2F</url>
    <content type="text"><![CDATA[一直想自己搭建一个博客，最近在空闲的时候陆陆续续搞了几天终于基本成功了，操作系统为Windows 7 64位。由于安装的时候没有截图，所以安装过程主要是文字，图片可以在最后的参考链接中看到一部分，希望可以给大家一些帮助。 我的搭建流程主要分以下几步： 在本地创建好博客文件并上传到github上，这样就可以在github上浏览自己的博客啦，详见这里 包括安装Node.js, git，hexo，注册github帐号等 为自己的博客设置一个域名，这样就可以从个性化的域名里直接访问博客，详见这里 包括域名购买，dns设置，pages设置等 其他优化，详见这里 本篇主要讲第一部分。 创建本地博客安装Node.js在这里下载Node，然后直接按提示安装即可。 安装git建议直接安装Github Desktop，这样可以直接用图形界面，方便今后往github上传代码。安装的时候会自动安装好git 安装hexo首先在本地创建一个存放博客文件的地方，比如我是放在了D:\blog下面。然后进入文件夹，在空白处按住shift加鼠标右键，选择“在此处打开命令窗口” 进入文件夹，在空白处按住shift加鼠标右键，选择“在此处打开命令窗口”。这里也可以在开始菜单搜索cmd然后一步步cd到文件夹里。 在命令行窗口中输入 sudo npm install -g hexo 安装好hexo后，执行init命令初始化hexo，在命令行窗口中输入 hexo init 然后安装所需要的组件,输入 npm install 至此，全部安装工作已经完成。blog就是你的博客根目录，所有的操作都在里面进行。 生成静态页面 hexo generate（hexo g也可以） 至此，本地博客已经创建完成。 创建github页面建立Github项目在Github上申请一个帐号，然后新建一个项目（repository），项目名为申请的账户名.github.io。 配置SSH配置SSH key，这样以后本地写好博客上传的时候就不需要帐号密码了。 在自己的用户目录下（一般为C:\Users\你的用户名）打开命令窗口，保证当前路径在用户目录下。在命令窗口中输入 ssh-keygen -t rsa -C &quot;xxxxxx@yy.com&quot; 邮箱名替换为自己的邮箱 然后用户目录下就会出现.ssh文件夹，进入文件夹中，打开id_rsa.pub文件（我是用Notepad++打开的），全选复制公钥内容。 登录GitHub，点击右上角账号头像的“▼” -&gt; Settings -&gt; SSH kyes -&gt; Add SSH key Titles随便取，将刚才复制的公钥粘贴到GitHub中Add an SSH key的key输入框，最后“Add Key”。 然后配置账户，分别在命令行窗口中输入 git config --global user.name “your_username” 替换成自己的用户名 git config --global user.email “your_registered_github_Email” 替换成自己的邮箱地址(建议用注册giuhub的邮箱) 配置后，在命令行窗口中输入 ssh -T git@github.com 跳出 Are you sure you want to continue connecting (yes/no)? 的时候，输入yes，出现 Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 后，说明设置成功。 本地配置在自己创建的文件夹中，找到_config.yml文件，修改最后的deploy部分为1234deploy: type: git repository: git@github.com:你的用户名/你的用户名.github.io.git branch: master 然后安装一个扩展，在命令行窗口中输入 npm install hexo-deployer-git --save 安装完成后，使用命令 hexo d -g 即可完成博客的生成与部署了 打开你的用户名.github.io.git，就可以看到自己创建的博客啦 参考网页 https://www.jianshu.com/p/465830080ea9https://www.cnblogs.com/fengxiongZz/p/7707219.htmlhttps://www.cnblogs.com/fengxiongZz/p/7707568.htmlhttps://jingyan.baidu.com/article/a65957f4e91ccf24e77f9b11.html]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
